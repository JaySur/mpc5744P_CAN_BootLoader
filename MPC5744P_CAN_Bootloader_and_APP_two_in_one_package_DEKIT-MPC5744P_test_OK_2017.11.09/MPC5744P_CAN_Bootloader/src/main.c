/*
 * main implementation: use this 'C' sample to create your own application
 *
 */

#include "derivative.h" /* include peripheral declarations */

#include "project.h"
#include "flexcan_init.h"
#include "FlexCAN_api.h"
#include "MPC574xP_SystemInit.h"

#include "load.h"

/* get the content(reset/start function address) of the user application project from its boot_reset_vector address*/
#define APP_StartAddr (*(uint32_t*)0x00FA0004)

/*
 * multicore interrupt(IVOR and INTC mode as well as CPU global interrupt enable) setup
 */
extern void xcptn_xmpl(void);

typedef void (* Jump_Func)(void);  /*the viod type function pointer definion for bootloader to user application jump*/

uint8_t STATE;          /*bootloader state machine*/
uint8_t pSln;           /*S-record line buffer pointor*/
uint8_t Sline[128];     /*S-record line buffer for temp store the received S-record from CAN bus*/



void app_entry(void)
{
	(*(void (*)(void))(APP_StartAddr))();/*run the function via function pointer convert with a certain address*/

	while(1);/*stop here for anyhow*/
}

int main(void)
{
	uint32_t i;                    	/* Index */
	
	uint32_t Srecord_address = 0;;   /*used to store S-Record line address */
	uint8_t Srecord_FLASH_line = 0;  /* flag of Flash line */

	xcptn_xmpl ();             /* Configure and Enable Interrupts */

	Sys_Init();                /*system initialization*/

	GPIO_Aux_Function_Config();/*configure GPIO function for LEDs and FlexCAN*/

	flexcan_0_init_fnc();      /*initialize the FlexCAN0 with 500Kbps  for CAN message TX/RX */

	Periphral_INTC_Init();     /* the peripheral interrupt INTC  priority initialization */

	/***********************************************************************
	 * wait 500ms for bootlader link request from host
	 ***********************************************************************/
	for(i=0; i<500; i++)
	{

		if((CAN0_BufferReceive_Flag!=0)&&(CAN_RxMsg.Frame_Data[0]==DOWN_LINK))
		{
			CAN0_BufferReceive_Flag = 0;    /*reset the CAN received flag*/
			STATE = _STA_LINKED;    		/*set bootloader state machine as linked for bootloader loop entry*/

			break;
		}
		else
		{
			Cpu_DelayMS(1);                /*delay 1ms per cycle*/
		}
	}

	if (STATE == _STA_NOT_LINKED)  /* no bootload link request during last 500ms */
	{

		Prepare_Before_Jump();    /*de-initialize the used peripherals and clean RAM*/

		app_entry();              /* jump to app and should not back   */
		for(;;) ;                 /* stop here however in case run away */
	}

	StatusAck(UP_READY);    /*feed back ready for receive new data download*/
	pSln = 0;               /*point to the position of a S-Record with a line */

	for(;;)
	{
		if(CAN0_BufferReceive_Flag)       /*is new CAN data received*/
		{
			CAN0_BufferReceive_Flag = 0;  /*clean the new CAN data received flag for new data*/

			switch (CAN_RxMsg.Frame_Data[0])
			{
				case DOWN_LINK:               /* still possible, since DownloadID < UploadID */
					StatusAck(UP_READY);      /*feed back ready for receive new data download*/
					break;

				case DOWN_LINE_END:           /* completed a line of Srecord receive*/
					StatusAck(UP_BUSY);       /*feed back busy for process, and PC teminal stop download data*/
					if(SPASS==SRcdCvt(&Sline[0], &srcd)) /*convert and S-record line is OK for bootloader*/
					{

					  Srecord_address = srcd.addr; /*get the S-record line address*/
					  if(RAM_RANGE_CHECK(Srecord_address))
					  {
						 SrcdProg_RAM(&srcd);   /*write the received data into RAM*/
					  }
					  else
					  {
						 if(Srecord_FLASH_line==0)
						 {
							 Srecord_FLASH_line = 1;/*the FLASH line has received*/

							 Flash_Init();			/*the Flash initialization can be put here for fast jump*/

							 SIUL2.GPDO[LED_R].B.PDO = 0;         /* start flash erasing  */
							 erase_flash_except_bootloader();	  /* erase the FLASH for data program*/
							 SIUL2.GPDO[LED_R].B.PDO = 1;         /* finish flash erasing   */

						 }

						 SIUL2.GPDO[LED_R].B.PDO = 0;             /*start Flash program*/

						 SrcdAlign4W(&srcd);       				  /*align to 4 Word*/
						 SrcdProg_PFlash(&srcd);   				  /*program a line*/

						 SIUL2.GPDO[LED_R].B.PDO = 1;             /*finished Flash program*/

					  }
					}

					pSln = 0;                 /*reset the S-record line buffer pointer for new line receive*/
					StatusAck(UP_READY);      /*feed back ready for receive new data download*/

					break;

				case DOWN_FILE_END:           /* completed trans of Srecord file   */
					StatusAck(UP_PRGEND);     /*feed back program end to PC teminal*/
					STATE=_STA_PRGEND;
					break;

				default:                             /* Srecord data received */
					for (i=0; i<CAN_RxMsg.Frame_Length; i++)    /*the default line length of S-record generated by CodeWarrior IDE is 0x20(32) Bytes*/
					{                                /*so it needs 4 CAN frame to transmit*/
						  Sline[pSln++]=CAN_RxMsg.Frame_Data[i]; /*store the CAN received data to S-record line buffer*/
					}
					  StatusAck(UP_READY);             /*feed back ready for receive new data download*/
					  break;
			}/*end if switch*/

			if(STATE==_STA_PRGEND)    /*P-Flash programmed OK*/
			{
				Prepare_Before_Jump();/*de-initialize the used peripherals and clean RAM*/
				app_entry();          /*jump to app and should not back */
				for(;;) ;			  /* stop here however in case run away */
			}
		}/*end of CAN0_BufferReceive_Flag==1 if*/
	}/*end of for loop*/

}

